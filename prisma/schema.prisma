// 1. Setting up the environment
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ====================================================================
// 2. ENUMS
// ====================================================================

// 2.1 User Roles
enum Role {
  ADMIN            // System Admin / Support Staff
  LECTURER         // General Lecturer
  PROGRAM_CHAIR    // Program Chair (1st Approval)
  VICE_DEAN        // Vice Dean (2nd Approval)
  USER             // Default role for new users
}

// 2.2 User Types
enum UserType {
  ACADEMIC // Academic Staff (Lecturers) -> Has teaching load
  SUPPORT  // Support Staff -> System/Document management
}

// 2.3 Approval Status
enum ApprovalStatus {
  PENDING   
  APPROVED  
  REJECTED  
  DRAFT     
}

// ====================================================================
// 3. MODELS
// ====================================================================

// 3.1 User Model (Updated for NextAuth)
model User {
  id        String   @id @default(cuid()) // Changed to String (cuid) for NextAuth compliance
  email     String?  @unique             
  name      String?  // Combined firstName + lastName for NextAuth
  emailVerified DateTime?
  image         String?
  
  // --- Personal Info (Matches JSON) ---
  title            String?  // Matches JSON: title
  academicPosition String?  // Matches JSON: academicPosition
  firstName        String?  // Matches JSON: firstName
  lastName         String?  // Matches JSON: lastName
  academicRank     String?  // Matches JSON: academicRank
  workStatus       String?  // Matches JSON: workStatus
  
  // --- Department & Admin Title ---
  department       String?  // Matches JSON: department (Subject Group)
  curriculum       String?  // Matches JSON: curriculum (Full Program Name for Type check)
  adminTitle       String?  // Matches JSON: role (Admin Position e.g., Program Chair)

  // --- System Data ---
  role       Role      @default(USER)     // System Role
  userType   UserType  @default(ACADEMIC) // Personnel Type
  
  // --- Relations (Existing) ---
  managedPrograms     Program[]             @relation("ProgramChair")
  teachingAssignments TeachingAssignment[]
  
  responsibleSubjects Subject[]             @relation("SubjectResponsible")
  
  // Approval Rights (Reverse Relations)
  chairApprovals TeachingAssignment[] @relation("ChairApprovals")
  deanApprovals  TeachingAssignment[] @relation("DeanApprovals")

  // --- NextAuth Relations (NEW) ---
  accounts      Account[]
  sessions      Session[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("user")
}

// ====================================================================
// NEXTAUTH REQUIRED MODELS (NEW)
// ====================================================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  ext_expires_in     Int?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("account")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtoken")
}

// ====================================================================
// YOUR EXISTING MODELS (Adjusted for User ID type change)
// ====================================================================

// 3.2 Program Model
model Program {
  id              Int       @id @default(autoincrement())
  name_th         String    // Program Name (TH)
  degree_level    String    // Degree Level
  year            Int       // Year (B.E.)
  
  programChairId       String?   // Changed to String to match User.id
  programChair         User?     @relation("ProgramChair", fields: [programChairId], references: [id])
  
  subjects         Subject[]

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("program")
}

// 3.3 Subject Model
model Subject {
  id                Int        @id @default(autoincrement())
  code              String     // Subject Code
  name_th           String     // Subject Name (TH)
  name_en           String?    // Subject Name (EN)
  credit            String     // Credit (Stored as String e.g. "3(2-3-5)")
  
  // Quick text display. Approval logic resides in TeachingAssignment
  instructor        String?    @db.Text 
  
  program_full_name String?    // Full Program Name (For validation)
  
  programId       Int
  program         Program  @relation(fields: [programId], references: [id])
  
  responsibleUserId String?  // Changed to String to match User.id
  responsibleUser   User?      @relation("SubjectResponsible", fields: [responsibleUserId], references: [id])

  teachingAssignments TeachingAssignment[]

  // Unique constraint for code within a program
  @@unique([code, programId]) 

  @@map("subject")
}

// 3.4 Teaching Assignment (Core of the flow)
model TeachingAssignment {
  id              Int        @id @default(autoincrement())
  
  academicYear    Int        
  semester        Int        
  section         String?    
  
  // --- Teaching Hours ---
  lectureHours    Float      @default(0.0) 
  labHours        Float      @default(0.0) 
  examHours       Float      @default(0)

  // =================================================================
  // 4-STEP APPROVAL FLOW
  // =================================================================

  // STEP 1: Lecturer Verification
  lecturerStatus        ApprovalStatus @default(PENDING) 
  lecturerFeedback      String?        @db.Text // Feedback message for correction
  lecturerActionAt      DateTime?

  // STEP 2: Responsible Subject User Review
  responsibleStatus     ApprovalStatus @default(PENDING)
  responsibleActionAt   DateTime?

  // STEP 3: Program Chair Approval
  headApprovalStatus ApprovalStatus @default(PENDING) 
  headApprovedAt     DateTime?
  headApproverId     String?  // Changed to String
  headApprover       User?       @relation("ChairApprovals", fields: [headApproverId], references: [id])

  // STEP 4: Vice Dean Approval
  deanApprovalStatus ApprovalStatus @default(PENDING) 
  deanApprovedAt     DateTime?
  deanApproverId     String?  // Changed to String
  deanApprover       User?       @relation("DeanApprovals", fields: [deanApproverId], references: [id])

  // --- Relations ---
  lecturerId      String   // Changed to String
  lecturer        User        @relation(fields: [lecturerId], references: [id], onDelete: Cascade)
  subjectId       Int
  subject         Subject     @relation(fields: [subjectId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([lecturerId, academicYear, semester])

  @@map("teachingassignment")
}